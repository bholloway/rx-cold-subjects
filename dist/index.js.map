{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap c899fcd4826d264e087c","webpack:///./index.js","webpack:///./utility/subclass-with.js","webpack:///external \"Rx\"","webpack:///./operator/behavior.js","webpack:///./~/rxjs/operator/multicast.js","webpack:///./~/rxjs/observable/ConnectableObservable.js","webpack:///./~/rxjs/Observable.js","webpack:///./~/rxjs/util/root.js","webpack:///(webpack)/buildin/module.js","webpack:///./~/rxjs/util/SymbolShim.js","webpack:///./~/rxjs/util/toSubscriber.js","webpack:///./~/rxjs/Subscriber.js","webpack:///./~/rxjs/util/noop.js","webpack:///./~/rxjs/util/throwError.js","webpack:///./~/rxjs/util/tryOrThrowError.js","webpack:///./~/rxjs/Subscription.js","webpack:///./~/rxjs/util/isArray.js","webpack:///./~/rxjs/util/isObject.js","webpack:///./~/rxjs/util/isFunction.js","webpack:///./~/rxjs/symbol/rxSubscriber.js","webpack:///./~/rxjs/Observer.js","webpack:///./operator/disposable.js","webpack:///./operator/lifecycle.js","webpack:///./operator/stimulus.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,G;;;;;;;;;AChBA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,YAAW,SAAS;AACpB,cAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+B;;;;;;;;;AC1FA,gD;;;;;;;;;ACAA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV,YAAW,EAAE;AACb,cAAa,mBAAmB;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,gBAAgB;AACjC,kBAAiB,cAAc;AAC/B;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;ACdA;AACA;AACA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA,mCAAkC,cAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD,kD;;;;;;;;;ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,SAAS;AACxB,kBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,kBAAkB;AACjC;AACA,gBAAe,SAAS;AACxB;AACA,gBAAe,SAAS;AACxB,kBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,SAAS;AACxB,gBAAe,IAAI;AACnB,gBAAe,mBAAmB;AAClC,kBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,SAAS;AACxB,kBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA,uC;;;;;;;;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;;;;;;ACjBA;AACA;AACA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,gCAAgC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD,uC;;;;;;;;;AC5GA;AACA,kBAAiB;AACjB;AACA,iC;;;;;;;;;ACHA,yBAAwB,SAAS;AACjC;AACA,uC;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4C;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,EAAC;AACD;AACA,yC;;;;;;;;;ACjFA,mDAAkD,0CAA0C,EAAE;AAC9F,oC;;;;;;;;;ACDA;AACA;AACA;AACA;AACA,qC;;;;;;;;;ACJA;AACA;AACA;AACA;AACA,uC;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;;;;;;ACRA;AACA;AACA,6BAA4B,EAAE;AAC9B,4BAA2B,WAAW,EAAE;AACxC,4BAA2B;AAC3B;AACA,qC;;;;;;;;;ACNA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV,YAAW,QAAQ;AACnB,cAAa,qBAAqB;AAClC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,mBAAmB;AACpC;AACA,IAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;ACvFA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV,YAAW,QAAQ;AACnB,cAAa,oBAAoB;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB;AAChB,IAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;ACxGA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV,YAAW,QAAQ;AACnB,cAAa,mBAAmB;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"Rx\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"Rx\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"RxOperators\"] = factory(require(\"Rx\"));\n\telse\n\t\troot[\"RxOperators\"] = factory(root[\"Rx\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_3__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap c899fcd4826d264e087c\n **/","/*\n * MIT License http://opensource.org/licenses/MIT\n * Author: Ben Holloway @bholloway\n */\n'use strict';\n\nmodule.exports = {\n  utilty  : {\n    subclassWith: require('./utility/subclass-with')\n  },\n  operator: {\n    behavior  : require('./operator/behavior'),\n    disposable: require('./operator/disposable'),\n    lifecycle : require('./operator/lifecycle'),\n    stimulus  : require('./operator/stimulus')\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.js\n ** module id = 1\n ** module chunks = 0\n **/","'use strict';\n\nvar Observable = require('rxjs').Observable;\n\n/**\n * Create a subclass of `Rx.Observable`, or the given `BaseClass`, that includes the given operators.\n *\n * Implements instance `lift()` and static `from()` methods.\n *\n * @param {object} operators A hash of operator functions or property definitions for the prototype\n * @param {function} [BaseClass] Optional subclass of Observable to use as the base class\n * @param {function} [constructor] Optional constructor implementation\n * @returns {function} A subclass of Observable that includes the given operators\n */\nfunction subclassWith(operators, BaseClass, constructor) {\n  BaseClass = BaseClass || Observable;\n  constructor = constructor || BaseClass;\n\n  // Observable or its subclasses\n  if (!getObservablePrototype(BaseClass)) {\n    throw new TypeError('given BaseClass must be Rx.Observable or one of its sub-classes');\n  }\n\n  var SubClass = function SubClass() {\n    constructor.apply(this, Array.prototype.slice.call(arguments));\n  };\n\n  // static methods\n  SubClass.from = from;\n\n  // instance methods\n  SubClass.prototype = Object.create(BaseClass.prototype);\n  SubClass.prototype.constructor = SubClass;\n  SubClass.prototype.lift = lift;\n\n  for (var key in operators) {\n    if (operators.hasOwnProperty(key)) {\n      var value = operators[key];\n\n      // functions are assigned\n      if (typeof value === 'function') {\n        SubClass.prototype[key] = value;\n      }\n      // objects are treated as property definitions\n      else if (typeof value === 'object') {\n        Object.defineProperty(SubClass.prototype, key, value);\n      }\n    }\n  }\n\n  return SubClass;\n\n  function lift(operator) {\n    /* jshint validthis:true */\n    var observable = new SubClass();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  function from(observable) {\n    /* jshint validthis:true */\n    var prototype = getObservablePrototype(observable);\n\n    // ensure any instance of Observable or its subclasses\n    if (!prototype) {\n      throw new TypeError('given observable must be an instance of Rx.Observable or one of its sub-classes');\n    }\n    // idempotent where the given observable is the same class\n    else if (prototype === SubClass.prototype) {\n      return this;\n    }\n    // mismatch class implies new instance (similar to Observable.lift)\n    else {\n      var result = new SubClass();\n      result.source = observable;\n      result.operator = observable.operator;\n      return result;\n    }\n  }\n\n  function getObservablePrototype(candidate) {\n    var prototype = (typeof candidate === 'function') ? BaseClass.prototype :\n          (typeof candidate === 'object') ? Object.getPrototypeOf(candidate) : null,\n        isValid   = !!prototype && (typeof prototype === 'object') &&\n          ((prototype === Observable.prototype) || (prototype instanceof Observable));\n    return isValid && prototype;\n  }\n}\n\nmodule.exports = subclassWith;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./utility/subclass-with.js\n ** module id = 2\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"Rx\"\n ** module id = 3\n ** module chunks = 0\n **/","'use strict';\n\nvar Rx                 = require('rxjs'),\n    multicast          = require('rxjs/operator/multicast').multicast,\n    RefCountObservable = (new Rx.ConnectableObservable()).refCount().constructor;\n\nvar subclassWith = require('../utility/subclass-with');\n\n/**\n * Represents a value that changes over time. Observers can subscribe to the subject to receive the last (or initial)\n * value and all subsequent notifications, unless or until the source Observable is complete.\n *\n * Exposes a `clear()` method that will re-instate the `initialValue`.\n *\n * Exposes an `isValid` flag which negates any time the current value is the `initialValue` (by strict equality).\n *\n * @this {Observable}\n * @param {*} [initialValue] Optional value to use when invalid (default `undefined`)\n * @returns {BehaviorObservable} A RefCountObservable with additional `clear()` method, and `isValid:boolean` and\n * `value:*` fields\n */\nfunction behavior(initialValue) {\n  /* jshint validthis:true */\n\n  // create a sub-class of RefCountObservable\n  //  infer the RefCountObservable class definition by one of its instances\n  var BehaviorObservable = subclassWith({\n    isValid   : {get: getIsValid},\n    value     : {get: getValue},\n    clear     : clear,\n    lift      : lift\n  }, RefCountObservable, constructor);\n\n  return new BehaviorObservable(this, initialValue);\n\n  function lift(operator) {\n    /* jshint validthis:true */\n    var observable = new Rx.Observable();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n}\n\nmodule.exports = behavior;\n\n/**\n * Constructor for the BehaviorObservable class\n */\nfunction constructor(source, initialValue) {\n  /* jshint validthis:true */\n  var that = this;\n\n  // create the subject\n  var subject = new Rx.BehaviorSubject(initialValue);\n\n  // quietly go to disposed state when the source Observable errors or completes\n  var monitored = source.do(undefined, setDisposed, setDisposed);\n\n  // super()\n  RefCountObservable.call(this, multicast.call(monitored, subject));\n\n  // private members\n  this._initialValue = initialValue;\n  this._subject = subject;\n  this._isDisposed = false;\n\n  function setDisposed() {\n    that._isDisposed = true;\n  }\n}\n\n/**\n * Flag negates any time the current value on the StimulusObservable instance is the `initialValue` (by strict equality)\n */\nfunction getIsValid() {\n  /* jshint validthis:true */\n  return !this._isDisposed && (this._subject.getValue() !== this._initialValue);\n}\n\n/**\n * The current value of the instance.\n */\nfunction getValue() {\n  /* jshint validthis:true */\n  return this._subject.getValue();\n}\n\n/**\n * Re-instate the `initialValue` on the StimulusObservable instance\n */\nfunction clear() {\n  /* jshint validthis:true */\n  if (this.isValid) {\n    this._subject.next(this._initialValue);\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./operator/behavior.js\n ** module id = 4\n ** module chunks = 0\n **/","var ConnectableObservable_1 = require('../observable/ConnectableObservable');\nfunction multicast(subjectOrSubjectFactory) {\n    var subjectFactory;\n    if (typeof subjectOrSubjectFactory === 'function') {\n        subjectFactory = subjectOrSubjectFactory;\n    }\n    else {\n        subjectFactory = function subjectFactory() {\n            return subjectOrSubjectFactory;\n        };\n    }\n    return new ConnectableObservable_1.ConnectableObservable(this, subjectFactory);\n}\nexports.multicast = multicast;\n//# sourceMappingURL=multicast.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/operator/multicast.js\n ** module id = 5\n ** module chunks = 0\n **/","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar Observable_1 = require('../Observable');\nvar Subscriber_1 = require('../Subscriber');\nvar Subscription_1 = require('../Subscription');\nvar ConnectableObservable = (function (_super) {\n    __extends(ConnectableObservable, _super);\n    function ConnectableObservable(source, subjectFactory) {\n        _super.call(this);\n        this.source = source;\n        this.subjectFactory = subjectFactory;\n    }\n    ConnectableObservable.prototype._subscribe = function (subscriber) {\n        return this._getSubject().subscribe(subscriber);\n    };\n    ConnectableObservable.prototype._getSubject = function () {\n        var subject = this.subject;\n        if (subject && !subject.isUnsubscribed) {\n            return subject;\n        }\n        return (this.subject = this.subjectFactory());\n    };\n    ConnectableObservable.prototype.connect = function () {\n        var source = this.source;\n        var subscription = this.subscription;\n        if (subscription && !subscription.isUnsubscribed) {\n            return subscription;\n        }\n        subscription = source.subscribe(this._getSubject());\n        subscription.add(new ConnectableSubscription(this));\n        return (this.subscription = subscription);\n    };\n    ConnectableObservable.prototype.refCount = function () {\n        return new RefCountObservable(this);\n    };\n    return ConnectableObservable;\n})(Observable_1.Observable);\nexports.ConnectableObservable = ConnectableObservable;\nvar ConnectableSubscription = (function (_super) {\n    __extends(ConnectableSubscription, _super);\n    function ConnectableSubscription(connectable) {\n        _super.call(this);\n        this.connectable = connectable;\n    }\n    ConnectableSubscription.prototype._unsubscribe = function () {\n        var connectable = this.connectable;\n        connectable.subject = null;\n        connectable.subscription = null;\n        this.connectable = null;\n    };\n    return ConnectableSubscription;\n})(Subscription_1.Subscription);\nvar RefCountObservable = (function (_super) {\n    __extends(RefCountObservable, _super);\n    function RefCountObservable(connectable, refCount) {\n        if (refCount === void 0) { refCount = 0; }\n        _super.call(this);\n        this.connectable = connectable;\n        this.refCount = refCount;\n    }\n    RefCountObservable.prototype._subscribe = function (subscriber) {\n        var connectable = this.connectable;\n        var refCountSubscriber = new RefCountSubscriber(subscriber, this);\n        var subscription = connectable.subscribe(refCountSubscriber);\n        if (!subscription.isUnsubscribed && ++this.refCount === 1) {\n            refCountSubscriber.connection = this.connection = connectable.connect();\n        }\n        return subscription;\n    };\n    return RefCountObservable;\n})(Observable_1.Observable);\nvar RefCountSubscriber = (function (_super) {\n    __extends(RefCountSubscriber, _super);\n    function RefCountSubscriber(destination, refCountObservable) {\n        _super.call(this, null);\n        this.destination = destination;\n        this.refCountObservable = refCountObservable;\n        this.connection = refCountObservable.connection;\n        destination.add(this);\n    }\n    RefCountSubscriber.prototype._next = function (value) {\n        this.destination.next(value);\n    };\n    RefCountSubscriber.prototype._error = function (err) {\n        this._resetConnectable();\n        this.destination.error(err);\n    };\n    RefCountSubscriber.prototype._complete = function () {\n        this._resetConnectable();\n        this.destination.complete();\n    };\n    RefCountSubscriber.prototype._resetConnectable = function () {\n        var observable = this.refCountObservable;\n        var obsConnection = observable.connection;\n        var subConnection = this.connection;\n        if (subConnection && subConnection === obsConnection) {\n            observable.refCount = 0;\n            obsConnection.unsubscribe();\n            observable.connection = null;\n            this.unsubscribe();\n        }\n    };\n    RefCountSubscriber.prototype._unsubscribe = function () {\n        var observable = this.refCountObservable;\n        if (observable.refCount === 0) {\n            return;\n        }\n        if (--observable.refCount === 0) {\n            var obsConnection = observable.connection;\n            var subConnection = this.connection;\n            if (subConnection && subConnection === obsConnection) {\n                obsConnection.unsubscribe();\n                observable.connection = null;\n            }\n        }\n    };\n    return RefCountSubscriber;\n})(Subscriber_1.Subscriber);\n//# sourceMappingURL=ConnectableObservable.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/observable/ConnectableObservable.js\n ** module id = 6\n ** module chunks = 0\n **/","var root_1 = require('./util/root');\nvar SymbolShim_1 = require('./util/SymbolShim');\nvar toSubscriber_1 = require('./util/toSubscriber');\n/**\n * A representation of any set of values over any amount of time. This the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nvar Observable = (function () {\n    /**\n     * @constructor\n     * @param {Function} subscribe the function that is\n     * called when the Observable is initially subscribed to. This function is given a Subscriber, to which new values\n     * can be `next`ed, or an `error` method can be called to raise an error, or `complete` can be called to notify\n     * of a successful completion.\n     */\n    function Observable(subscribe) {\n        this._isScalar = false;\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    /**\n     * @method lift\n     * @param {Operator} operator the operator defining the operation to take on the observable\n     * @returns {Observable} a new observable with the Operator applied\n     * @description creates a new Observable, with this Observable as the source, and the passed\n     * operator defined as the new observable's operator.\n     */\n    Observable.prototype.lift = function (operator) {\n        var observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    /**\n     * @method subscribe\n     * @param {Observer|Function} observerOrNext (optional) either an observer defining all functions to be called,\n     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.\n     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,\n     *  the error will be thrown as unhandled\n     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.\n     * @returns {Subscription} a subscription reference to the registered handlers\n     * @description registers handlers for handling emitted values, error and completions from the observable, and\n     *  executes the observable's subscriber function, which will take action to set up the underlying data stream\n     */\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n        var operator = this.operator;\n        var subscriber = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n        if (operator) {\n            subscriber.add(this._subscribe(this.operator.call(subscriber)));\n        }\n        else {\n            subscriber.add(this._subscribe(subscriber));\n        }\n        return subscriber;\n    };\n    /**\n     * @method forEach\n     * @param {Function} next a handler for each value emitted by the observable\n     * @param {any} [thisArg] a `this` context for the `next` handler function\n     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n     * @returns {Promise} a promise that either resolves on observable completion or\n     *  rejects with the handled error\n     */\n    Observable.prototype.forEach = function (next, thisArg, PromiseCtor) {\n        if (!PromiseCtor) {\n            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n                PromiseCtor = root_1.root.Rx.config.Promise;\n            }\n            else if (root_1.root.Promise) {\n                PromiseCtor = root_1.root.Promise;\n            }\n        }\n        if (!PromiseCtor) {\n            throw new Error('no Promise impl found');\n        }\n        var nextHandler;\n        if (thisArg) {\n            nextHandler = function nextHandlerFn(value) {\n                var _a = nextHandlerFn, thisArg = _a.thisArg, next = _a.next;\n                return next.call(thisArg, value);\n            };\n            nextHandler.thisArg = thisArg;\n            nextHandler.next = next;\n        }\n        else {\n            nextHandler = next;\n        }\n        var promiseCallback = function promiseCallbackFn(resolve, reject) {\n            var _a = promiseCallbackFn, source = _a.source, nextHandler = _a.nextHandler;\n            source.subscribe(nextHandler, reject, resolve);\n        };\n        promiseCallback.source = this;\n        promiseCallback.nextHandler = nextHandler;\n        return new PromiseCtor(promiseCallback);\n    };\n    Observable.prototype._subscribe = function (subscriber) {\n        return this.source.subscribe(subscriber);\n    };\n    /**\n     * @method Symbol.observable\n     * @returns {Observable} this instance of the observable\n     * @description an interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n     */\n    Observable.prototype[SymbolShim_1.SymbolShim.observable] = function () {\n        return this;\n    };\n    // HACK: Since TypeScript inherits static properties too, we have to\n    // fight against TypeScript here so Subject can have a different static create signature\n    /**\n     * @static\n     * @method create\n     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n     * @returns {Observable} a new cold observable\n     * @description creates a new cold Observable by calling the Observable constructor\n     */\n    Observable.create = function (subscribe) {\n        return new Observable(subscribe);\n    };\n    return Observable;\n})();\nexports.Observable = Observable;\n//# sourceMappingURL=Observable.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/Observable.js\n ** module id = 7\n ** module chunks = 0\n **/","var objectTypes = {\n    'boolean': false,\n    'function': true,\n    'object': true,\n    'number': false,\n    'string': false,\n    'undefined': false\n};\nexports.root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);\n/* tslint:disable:no-unused-variable */\nvar freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;\nvar freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\nvar freeGlobal = objectTypes[typeof global] && global;\nif (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {\n    exports.root = freeGlobal;\n}\n//# sourceMappingURL=root.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/root.js\n ** module id = 8\n ** module chunks = 0\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 9\n ** module chunks = 0\n **/","var root_1 = require('./root');\nfunction polyfillSymbol(root) {\n    var Symbol = ensureSymbol(root);\n    ensureIterator(Symbol, root);\n    ensureObservable(Symbol);\n    ensureFor(Symbol);\n    return Symbol;\n}\nexports.polyfillSymbol = polyfillSymbol;\nfunction ensureFor(Symbol) {\n    if (!Symbol.for) {\n        Symbol.for = symbolForPolyfill;\n    }\n}\nexports.ensureFor = ensureFor;\nvar id = 0;\nfunction ensureSymbol(root) {\n    if (!root.Symbol) {\n        root.Symbol = function symbolFuncPolyfill(description) {\n            return \"@@Symbol(\" + description + \"):\" + id++;\n        };\n    }\n    return root.Symbol;\n}\nexports.ensureSymbol = ensureSymbol;\nfunction symbolForPolyfill(key) {\n    return '@@' + key;\n}\nexports.symbolForPolyfill = symbolForPolyfill;\nfunction ensureIterator(Symbol, root) {\n    if (!Symbol.iterator) {\n        if (typeof Symbol.for === 'function') {\n            Symbol.iterator = Symbol.for('iterator');\n        }\n        else if (root.Set && typeof new root.Set()['@@iterator'] === 'function') {\n            // Bug for mozilla version\n            Symbol.iterator = '@@iterator';\n        }\n        else if (root.Map) {\n            // es6-shim specific logic\n            var keys = Object.getOwnPropertyNames(root.Map.prototype);\n            for (var i = 0; i < keys.length; ++i) {\n                var key = keys[i];\n                if (key !== 'entries' && key !== 'size' && root.Map.prototype[key] === root.Map.prototype['entries']) {\n                    Symbol.iterator = key;\n                    break;\n                }\n            }\n        }\n        else {\n            Symbol.iterator = '@@iterator';\n        }\n    }\n}\nexports.ensureIterator = ensureIterator;\nfunction ensureObservable(Symbol) {\n    if (!Symbol.observable) {\n        if (typeof Symbol.for === 'function') {\n            Symbol.observable = Symbol.for('observable');\n        }\n        else {\n            Symbol.observable = '@@observable';\n        }\n    }\n}\nexports.ensureObservable = ensureObservable;\nexports.SymbolShim = polyfillSymbol(root_1.root);\n//# sourceMappingURL=SymbolShim.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/SymbolShim.js\n ** module id = 10\n ** module chunks = 0\n **/","var Subscriber_1 = require('../Subscriber');\nvar rxSubscriber_1 = require('../symbol/rxSubscriber');\nfunction toSubscriber(next, error, complete) {\n    if (next && typeof next === 'object') {\n        if (next instanceof Subscriber_1.Subscriber) {\n            return next;\n        }\n        else if (typeof next[rxSubscriber_1.rxSubscriber] === 'function') {\n            return next[rxSubscriber_1.rxSubscriber]();\n        }\n        else {\n            return new Subscriber_1.Subscriber(next);\n        }\n    }\n    return Subscriber_1.Subscriber.create(next, error, complete);\n}\nexports.toSubscriber = toSubscriber;\n//# sourceMappingURL=toSubscriber.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/toSubscriber.js\n ** module id = 11\n ** module chunks = 0\n **/","var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar noop_1 = require('./util/noop');\nvar throwError_1 = require('./util/throwError');\nvar tryOrThrowError_1 = require('./util/tryOrThrowError');\nvar Subscription_1 = require('./Subscription');\nvar rxSubscriber_1 = require('./symbol/rxSubscriber');\nvar Observer_1 = require('./Observer');\nvar Subscriber = (function (_super) {\n    __extends(Subscriber, _super);\n    function Subscriber(destination) {\n        if (destination === void 0) { destination = Observer_1.empty; }\n        _super.call(this);\n        this.isStopped = false;\n        this.destination = destination;\n        if (!destination ||\n            (destination instanceof Subscriber) ||\n            (destination === Observer_1.empty)) {\n            return;\n        }\n        if (typeof destination.next !== 'function') {\n            destination.next = noop_1.noop;\n        }\n        if (typeof destination.error !== 'function') {\n            destination.error = throwError_1.throwError;\n        }\n        if (typeof destination.complete !== 'function') {\n            destination.complete = noop_1.noop;\n        }\n    }\n    Subscriber.create = function (next, error, complete) {\n        return new SafeSubscriber(next, error, complete);\n    };\n    Subscriber.prototype.next = function (value) {\n        if (!this.isStopped) {\n            this._next(value);\n        }\n    };\n    Subscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._error(err);\n        }\n    };\n    Subscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._complete();\n        }\n    };\n    Subscriber.prototype.unsubscribe = function () {\n        if (this.isUnsubscribed) {\n            return;\n        }\n        this.isStopped = true;\n        _super.prototype.unsubscribe.call(this);\n    };\n    Subscriber.prototype._next = function (value) {\n        this.destination.next(value);\n    };\n    Subscriber.prototype._error = function (err) {\n        this.destination.error(err);\n        this.unsubscribe();\n    };\n    Subscriber.prototype._complete = function () {\n        this.destination.complete();\n        this.unsubscribe();\n    };\n    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () {\n        return this;\n    };\n    return Subscriber;\n})(Subscription_1.Subscription);\nexports.Subscriber = Subscriber;\nvar SafeSubscriber = (function (_super) {\n    __extends(SafeSubscriber, _super);\n    function SafeSubscriber(next, error, complete) {\n        _super.call(this);\n        this._next = (typeof next === 'function') && tryOrThrowError_1.tryOrThrowError(next) || null;\n        this._error = (typeof error === 'function') && tryOrThrowError_1.tryOrThrowError(error) || throwError_1.throwError;\n        this._complete = (typeof complete === 'function') && tryOrThrowError_1.tryOrThrowError(complete) || null;\n    }\n    SafeSubscriber.prototype.next = function (value) {\n        if (!this.isStopped && this._next) {\n            this._next(value);\n        }\n    };\n    SafeSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            if (this._error) {\n                this._error(err);\n            }\n            this.unsubscribe();\n        }\n    };\n    SafeSubscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            if (this._complete) {\n                this._complete();\n            }\n            this.unsubscribe();\n        }\n    };\n    return SafeSubscriber;\n})(Subscriber);\n//# sourceMappingURL=Subscriber.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/Subscriber.js\n ** module id = 12\n ** module chunks = 0\n **/","/* tslint:disable:no-empty */\nfunction noop() { }\nexports.noop = noop;\n//# sourceMappingURL=noop.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/noop.js\n ** module id = 13\n ** module chunks = 0\n **/","function throwError(e) { throw e; }\nexports.throwError = throwError;\n//# sourceMappingURL=throwError.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/throwError.js\n ** module id = 14\n ** module chunks = 0\n **/","function tryOrThrowError(target) {\n    function tryCatcher() {\n        try {\n            tryCatcher.target.apply(this, arguments);\n        }\n        catch (e) {\n            throw e;\n        }\n    }\n    tryCatcher.target = target;\n    return tryCatcher;\n}\nexports.tryOrThrowError = tryOrThrowError;\n//# sourceMappingURL=tryOrThrowError.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/tryOrThrowError.js\n ** module id = 15\n ** module chunks = 0\n **/","var isArray_1 = require('./util/isArray');\nvar isObject_1 = require('./util/isObject');\nvar isFunction_1 = require('./util/isFunction');\nvar Subscription = (function () {\n    function Subscription(_unsubscribe) {\n        this.isUnsubscribed = false;\n        if (_unsubscribe) {\n            this._unsubscribe = _unsubscribe;\n        }\n    }\n    Subscription.prototype.unsubscribe = function () {\n        if (this.isUnsubscribed) {\n            return;\n        }\n        this.isUnsubscribed = true;\n        var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n        this._subscriptions = null;\n        if (isFunction_1.isFunction(_unsubscribe)) {\n            _unsubscribe.call(this);\n        }\n        if (isArray_1.isArray(_subscriptions)) {\n            var index = -1;\n            var len = _subscriptions.length;\n            while (++index < len) {\n                var subscription = _subscriptions[index];\n                if (isObject_1.isObject(subscription)) {\n                    subscription.unsubscribe();\n                }\n            }\n        }\n    };\n    Subscription.prototype.add = function (subscription) {\n        // return early if:\n        //  1. the subscription is null\n        //  2. we're attempting to add our this\n        //  3. we're attempting to add the static `empty` Subscription\n        if (!subscription || (subscription === this) || (subscription === Subscription.EMPTY)) {\n            return;\n        }\n        var sub = subscription;\n        switch (typeof subscription) {\n            case 'function':\n                sub = new Subscription(subscription);\n            case 'object':\n                if (sub.isUnsubscribed || typeof sub.unsubscribe !== 'function') {\n                    break;\n                }\n                else if (this.isUnsubscribed) {\n                    sub.unsubscribe();\n                }\n                else {\n                    (this._subscriptions || (this._subscriptions = [])).push(sub);\n                }\n                break;\n            default:\n                throw new Error('Unrecognized subscription ' + subscription + ' added to Subscription.');\n        }\n    };\n    Subscription.prototype.remove = function (subscription) {\n        // return early if:\n        //  1. the subscription is null\n        //  2. we're attempting to remove ourthis\n        //  3. we're attempting to remove the static `empty` Subscription\n        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {\n            return;\n        }\n        var subscriptions = this._subscriptions;\n        if (subscriptions) {\n            var subscriptionIndex = subscriptions.indexOf(subscription);\n            if (subscriptionIndex !== -1) {\n                subscriptions.splice(subscriptionIndex, 1);\n            }\n        }\n    };\n    Subscription.EMPTY = (function (empty) {\n        empty.isUnsubscribed = true;\n        return empty;\n    }(new Subscription()));\n    return Subscription;\n})();\nexports.Subscription = Subscription;\n//# sourceMappingURL=Subscription.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/Subscription.js\n ** module id = 16\n ** module chunks = 0\n **/","exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\n//# sourceMappingURL=isArray.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/isArray.js\n ** module id = 17\n ** module chunks = 0\n **/","function isObject(x) {\n    return x != null && typeof x === 'object';\n}\nexports.isObject = isObject;\n//# sourceMappingURL=isObject.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/isObject.js\n ** module id = 18\n ** module chunks = 0\n **/","function isFunction(x) {\n    return typeof x === 'function';\n}\nexports.isFunction = isFunction;\n//# sourceMappingURL=isFunction.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/util/isFunction.js\n ** module id = 19\n ** module chunks = 0\n **/","var SymbolShim_1 = require('../util/SymbolShim');\n/**\n * rxSubscriber symbol is a symbol for retreiving an \"Rx safe\" Observer from an object\n * \"Rx safety\" can be defined as an object that has all of the traits of an Rx Subscriber,\n * including the ability to add and remove subscriptions to the subscription chain and\n * guarantees involving event triggering (can't \"next\" after unsubscription, etc).\n */\nexports.rxSubscriber = SymbolShim_1.SymbolShim.for('rxSubscriber');\n//# sourceMappingURL=rxSubscriber.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/symbol/rxSubscriber.js\n ** module id = 20\n ** module chunks = 0\n **/","exports.empty = {\n    isUnsubscribed: true,\n    next: function (value) { },\n    error: function (err) { throw err; },\n    complete: function () { }\n};\n//# sourceMappingURL=Observer.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/rxjs/Observer.js\n ** module id = 21\n ** module chunks = 0\n **/","'use strict';\n\nvar Rx                 = require('rxjs'),\n    multicast          = require('rxjs/operator/multicast').multicast,\n    RefCountObservable = (new Rx.ConnectableObservable()).refCount().constructor;\n\nvar subclassWith = require('../utility/subclass-with');\n\n/**\n * Represents a value that changes over time. Observers can subscribe to the subject to receive all subsequent\n * notifications, unless or until the source Observable (if given) is complete. May be explicitly completed\n * using an exposed `dispose()` method.\n *\n * May be called as an unbound closure but will not subscribe to any source Observable.\n *\n * An optional `subject` may be provided to dictate the nature of the multicast output and/or provide explicit\n * supplementary control of the Observable output. For example, pass `new Rx.BehaviorSubject()` to receive a\n * **behavior** output.\n *\n * Exposes a `dispose()` method which causes the Subject to `complete` if it has not already done so.\n *\n * Exposes an `isDisposed` flag which indicates whether the Subject has completed.\n *\n * @this {Observable|undefined}\n * @param {Subject} [subject] Optional existing Subject instance, similar to `multicast()` operator\n * @returns {DisposableObservable} A RefCountObservable with additional `dispose()` method\n */\nfunction disposable(subject) {\n  /* jshint validthis:true */\n\n  // use a degenerate observable where bound 'this' is not observable\n  var source = !!this && (typeof this === 'object') && (this instanceof Rx.Observable) && this || Rx.Observable.never();\n\n  // create a sub-class of RefCountObservable\n  //  infer the RefCountObservable class definition by one of its instances\n  var DisposableObservable = subclassWith({\n    isDisposed: {get: getIsDisposed},\n    dispose   : dispose\n  }, RefCountObservable, constructor);\n\n  return new DisposableObservable(source, subject);\n}\n\nmodule.exports = disposable;\n\n/**\n * Constructor for the DisposableObservable class\n */\nfunction constructor(source, subject) {\n  /* jshint validthis:true */\n  var that = this;\n\n  // default to vanilla subject\n  subject = subject || new Rx.Subject();\n\n  // quietly go to disposed state when the source Observable errors or completes\n  var monitored = source.do(undefined, setDisposed, setDisposed);\n\n  // super()\n  RefCountObservable.call(this, multicast.call(monitored, subject));\n\n  // private members\n  this._subject = subject;\n  this._isDisposed = false;\n\n  function setDisposed() {\n    that._isDisposed = true;\n  }\n}\n\n/**\n * Getter for the DisposableObservable instance `lifecycle` property\n */\nfunction getIsDisposed() {\n  /* jshint validthis:true */\n  return this._isDisposed;\n}\n\n/**\n * Notify complete on the DisposableObservable instance\n */\nfunction dispose() {\n  /* jshint validthis:true */\n  if (!this._isDisposed) {\n    this._isDisposed = true;\n    this._subject.complete();\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./operator/disposable.js\n ** module id = 22\n ** module chunks = 0\n **/","'use strict';\n\nvar Rx                 = require('rxjs'),\n    multicast          = require('rxjs/operator/multicast').multicast,\n    RefCountObservable = (new Rx.ConnectableObservable()).refCount().constructor;\n\nvar subclassWith = require('../utility/subclass-with');\n\n/**\n * Represents a value that changes over time. Observers can subscribe to the subject to receive all subsequent\n * notifications, unless or until the source Observable is complete. It is possible to observe the number of\n * subscribers.\n *\n * May be called as an unbound closure but will not subscribe to any source Observable.\n *\n * An optional `subject` may be provided to dictate the nature of the multicast output and/or provide explicit\n * supplementary control of the Observable output. For example, pass `new Rx.BehaviorSubject()` to receive a\n * **behavior** output.\n *\n * Exposes a `lifecycle` Observable which tracks the number of subscribers to the Observable proper. The `lifecycle`\n * will complete when the source Observable completes. The `lifecycle` is a **behavior** in that all new subscriptions\n * will immediately receive the current reference count as their first value, unless or until the source Observable is\n * complete.\n *\n * @this {Observable|undefined}\n * @param {Subject} [subject] Optional existing Subject instance, similar to `multicast()` operator\n * @returns {LifecycleObservable} A RefCountObservable with additional `lifecycle:Observable` field\n */\nfunction lifecycle(subject) {\n  /* jshint validthis:true */\n\n  // use a degenerate observable where bound 'this' is not observable\n  var source = !!this && (typeof this === 'object') && (this instanceof Rx.Observable) && this || Rx.Observable.never();\n\n  // create a sub-class of RefCountObservable\n  //  infer the RefCountObservable class definition by one of its instances\n  var LifecycleObservable = subclassWith({\n    lifecycle: {get: getLifecycle}\n  }, RefCountObservable, constructor);\n\n  return new LifecycleObservable(source, subject);\n}\n\nmodule.exports = lifecycle;\n\n/**\n * Constructor for the LifecycleObservable class\n */\nfunction constructor(source, subject) {\n  /* jshint validthis:true */\n  var that = this;\n\n  // default to vanilla subject\n  subject = subject || new Rx.Subject();\n\n  // quietly go to disposed state when the source Observable errors or completes\n  var monitored = source.do(undefined, setDisposed, setDisposed);\n\n  // super()\n  RefCountObservable.call(this, multicast.call(monitored, subject));\n\n  // private members\n  this._subscribe = _subscribe;\n\n  var countStimulus = this._countStimulus = new Rx.BehaviorSubject(0);\n\n  this._lifecycle = Rx.Observable.never()\n    .multicast(countStimulus)\n    .refCount();\n\n  function setDisposed() {\n    that._isDisposed = true;\n    that._countStimulus.complete();\n  }\n}\n\n/**\n * Getter for the LifecycleObservable instance `lifecycle` property\n */\nfunction getLifecycle() {\n  /* jshint validthis:true */\n  return this._lifecycle;\n}\n\n/**\n * Monkey-patch _subscribe method and defer to the RefCountObservable superclass\n */\nfunction _subscribe(subscriber) {\n  /* jshint validthis:true */\n  var that = this;\n\n  // call super._subscribe()\n  var subscription = Object.getPrototypeOf(Object.getPrototypeOf(this))\n    ._subscribe.call(this, subscriber);\n  that._countStimulus.next(that.refCount);\n\n  var _unsubscribe = subscription._unsubscribe.bind(subscription);\n\n  // money-patch _unsubscribe() and defer to the subscrition\n  subscription._unsubscribe = function unsubscribe() {\n    _unsubscribe(subscription);\n    that._countStimulus.next(that.refCount);\n  };\n  return subscription;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./operator/lifecycle.js\n ** module id = 23\n ** module chunks = 0\n **/","'use strict';\n\nvar Rx                 = require('rxjs'),\n    multicast          = require('rxjs/operator/multicast').multicast,\n    RefCountObservable = (new Rx.ConnectableObservable()).refCount().constructor;\n\nvar subclassWith = require('../utility/subclass-with');\n\n/**\n * Represents a value that changes over time. Observers can subscribe to the subject to receive all subsequent\n * notifications, unless or until the source Observable (if given) is complete. May be explicitly control Observable\n * output using the exposed `next()`, `error()`, and `complete()` methods.\n *\n * May be called as an unbound closure but will not subscribe to any source Observable.\n *\n * An optional `subject` may be provided to dictate the nature of the multicast output and/or provide explicit\n * supplementary control of the Observable output. For example, pass `new Rx.BehaviorSubject()` to receive a\n * **behavior** output.\n *\n * Exposes a `dispose()` method which causes the Subject to `complete` if it has not already done so.\n *\n * Exposes an `isDisposed` flag which indicates whether the Subject has completed.\n *\n * @this {Observable|undefined}\n * @param {Subject} [subject] Optional existing Subject instance, similar to `multicast()` operator\n * @returns {StimulusObservable} A RefCountObservable with additional `next()`, `error()`, and `complete()` methods\n */\nfunction stimulus(subject) {\n  /* jshint validthis:true */\n\n  // use a degenerate observable where bound 'this' is not observable\n  var source = !!this && (typeof this === 'object') && (this instanceof Rx.Observable) && this || Rx.Observable.never();\n\n  // create a sub-class of RefCountObservable\n  //  infer the RefCountObservable class definition by one of its instances\n  var StimulusObservable = subclassWith({\n    next    : next,\n    error   : error,\n    complete: complete\n  }, RefCountObservable, constructor);\n\n  return new StimulusObservable(source, subject);\n}\n\nmodule.exports = stimulus;\n\n/**\n * Constructor for the DisposableObservable class\n */\nfunction constructor(source, subject) {\n  /* jshint validthis:true */\n  var that = this;\n\n  // default to vanilla subject\n  subject = subject || new Rx.Subject();\n\n  // quietly go to disposed state when the source Observable errors or completes\n  var monitored = source.do(undefined, setDisposed, setDisposed);\n\n  // super()\n  RefCountObservable.call(this, multicast.call(monitored, subject));\n\n  // private members\n  this._subject = subject;\n  this._isDisposed = false;\n\n  function setDisposed() {\n    that._isDisposed = true;\n  }\n}\n\n/**\n * Notify next on the StimulusObservable instance\n */\nfunction next(value) {\n  /* jshint validthis:true */\n  if (!this._isDisposed) {\n    this._subject.next(value);\n  }\n}\n\n/**\n * Notify error on the StimulusObservable instance\n */\nfunction error(value) {\n  /* jshint validthis:true */\n  if (!this._isDisposed) {\n    this._subject.error(value);\n  }\n}\n\n/**\n * Notify complete on the StimulusObservable instance\n */\nfunction complete() {\n  /* jshint validthis:true */\n  if (!this._isDisposed) {\n    this._subject.complete();\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./operator/stimulus.js\n ** module id = 24\n ** module chunks = 0\n **/"],"sourceRoot":""}